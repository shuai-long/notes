[TOC]

# 反射 #

在 ABAP 中，反射是通过运行时类型服务 (RTTS) 提供的。该服务提供了两个主要功能：在运行时识别类型和描述，以及动态创建类型。更具体地说，RTTS 是以下各项的组合：

* RTTI ( *Run Time Type Identification* ) 

  运行时类型识别，类型识别和描述（类型自省）

* RTTC ( *RunTime Type Creation* ) 

  运行时类型创建，动态类型创建

所有与 RTTS 相关的类都命名为 *CL_ABAP_\*DESCR*，具体取决于该类所代表的类型种类。*CL_ABAP_ELEMDESCR* 是基本数据类型的描述类，*CL_ABAP_TABLEDESCR* 是表类型的描述类等等。这些动态是利用  *CL_ABAP_TYPEDESCR* 类及其子类实现的。对于不同的类型都有不同的描述类，为了得到一个类型的描述类, 你必须使用 CL_ABAP_TYPEDESCR 的静态方法来得到。在运行中，每一个类型只有一个描述类。

```abap
CL_ABAP_TYPEDESCR
  |--CL_ABAP_DATADESCR
  |   |--CL_ABAP_ELEMDESCR
  |   |--CL_ABAP_REFDESCR
  |   |--CL_ABAP_COMPLEXDESCR
  |       |--CL_ABAP_STRUCTDESCR
  |       |--CL_ABAP_TABLEDESCR
  |--CL_ABAP_OBJECTDESCR
     |--CL_ABAP_CLASSDESCR
     |--CL_ABAP_INTFDESCR
```

## RTTI 使用 ##

### 动态获取透明表或结构信息 ###

```ABAP
"根据结构名获取结构描述信息 "
  DATA: LR_STRUCT_TYPE TYPE REF TO CL_ABAP_STRUCTDESCR,
        LT_DETAIL      TYPE ABAP_COMPDESCR_TAB,
        LS_DETAIL      TYPE ABAP_COMPDESCR,
        LV_TYPE        TYPE STRING.

  "根据表或者结果获取其描述类
  LR_STRUCT_TYPE ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_NAME( 'PA0001' ).  "此处可以是一个透明表
*  LR_STRUCT_TYPE ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_NAME( 'P0001' ).  "也可以是一个结构

  "获取其结构名称
  LV_TYPE = LR_STRUCT_TYPE->GET_RELATIVE_NAME( ).

  "从结构描述信息中获取字段列表
  LT_DETAIL[] = LR_STRUCT_TYPE->COMPONENTS[].

  "输出结构中的字段列表
  LOOP AT LT_DETAIL INTO LS_DETAIL.
    WRITE :/ LS_DETAIL-NAME,
             LS_DETAIL-TYPE_KIND,
             LS_DETAIL-LENGTH,
             LS_DETAIL-DECIMALS.
  ENDLOOP.
```

### 动态获取程序内部表或结构信息 ###

* **获取内表的字段目录**

  ```ABAP
    DATA: LT_P0001           TYPE TABLE OF PA0001,
          LO_TABLE_TYPE      TYPE REF TO CL_ABAP_TABLEDESCR,
          LO_TABLE_LINE_TYPE TYPE REF TO CL_ABAP_STRUCTDESCR,
          LT_DETAIL          TYPE ABAP_COMPDESCR_TAB,
          LS_DETAIL          TYPE ABAP_COMPDESCR.
  
    "获取内表的描述类
    LO_TABLE_TYPE ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( LT_P0001 ).
    
    "根据内表描述类获取结构的描述类
    LO_TABLE_LINE_TYPE ?= LO_TABLE_TYPE->GET_TABLE_LINE_TYPE( ).
    
    "获取字段目录
    LT_DETAIL[] = LO_TABLE_LINE_TYPE->COMPONENTS.
  
    LOOP AT LT_DETAIL INTO LS_DETAIL.
      WRITE :/ LS_DETAIL-NAME,
               LS_DETAIL-TYPE_KIND,
               LS_DETAIL-LENGTH,
               LS_DETAIL-DECIMALS.
    ENDLOOP.
  ```

* **获取内部结构的字段目录**

  ```abap
    DATA: LS_P0001           TYPE PA0001,
          LO_TABLE_LINE_TYPE TYPE REF TO CL_ABAP_STRUCTDESCR,
          LT_DETAIL          TYPE ABAP_COMPDESCR_TAB,
          LS_DETAIL          TYPE ABAP_COMPDESCR.
  
    "获取内表的描述类
    LO_TABLE_LINE_TYPE ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( LS_P0001 ).
  
    "获取字段目录
    LT_DETAIL[] = LO_TABLE_LINE_TYPE->COMPONENTS.
  
    LOOP AT LT_DETAIL INTO LS_DETAIL.
      WRITE :/ LS_DETAIL-NAME,
               LS_DETAIL-TYPE_KIND,
               LS_DETAIL-LENGTH,
               LS_DETAIL-DECIMALS.
    ENDLOOP.
  ```

### 获取字段信息 ###

```abap
  DATA: LR_DATA_TYPE TYPE REF TO CL_ABAP_DATADESCR,
        FIELD        TYPE CHAR10,
        KIND(1)      TYPE C.

  "获取字段信息的描述类
  LR_DATA_TYPE ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( FIELD ).

  "获取数据元素类型 ,不会返回具体的类型, 返回的是E(基本类型)
  KIND = LR_DATA_TYPE->KIND.
```



### 获取数据元素信息 ###

```abap
  DATA: ELEM_TYPE     TYPE REF TO CL_ABAP_ELEMDESCR,
        MATNR         TYPE MATNR,
        KIND(1)       TYPE C,
        EDIT_MASK     TYPE STRING,
        HELP_ID       TYPE STRING,
        OUTPUT_LENGTH TYPE STRING.

  "获取数据元素的描述类
  ELEM_TYPE ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_DATA( MATNR ).

  "获取数据元素类型(不是精确类型,而是E:基本类型)
  KIND = ELEM_TYPE->KIND.

 "获取数据元素的EDIT_MASK
  EDIT_MASK = ELEM_TYPE->EDIT_MASK.

  "获取数据元素的 HELP_ID
  HELP_ID   = ELEM_TYPE->HELP_ID.

  "获取数据元素的 输出长度
  OUTPUT_LENGTH = ELEM_TYPE->OUTPUT_LENGTH.

  WRITE: / KIND,
           EDIT_MASK,
           HELP_ID,
           OUTPUT_LENGTH.
```

### 访问类的信息 ###

```abap
CLASS C1 DEFINITION.
  PUBLIC SECTION.
    DATA: C VALUE 'C'.
    METHODS: TEST.
ENDCLASS.

CLASS C1 IMPLEMENTATION.
  METHOD:TEST.
    WRITE:/ 'test'.
  ENDMETHOD.
ENDCLASS.

DATA: OREF TYPE REF TO OBJECT .

DATA: OREF_TYPEDESCR  TYPE REF TO CL_ABAP_TYPEDESCR,
      OREF_CLASSDESCR TYPE REF TO CL_ABAP_OBJECTDESCR.

DATA: GT_ATTRDESCR_TAB TYPE ABAP_ATTRDESCR_TAB WITH HEADER LINE, "类中的属性列表"
      GT_METHDESCR_TAB TYPE ABAP_METHDESCR_TAB WITH HEADER LINE. "类中的方法列表"

FIELD-SYMBOLS <FS_ATTR> TYPE ANY.

CREATE OBJECT OREF TYPE ('C1'). "C1为类名"

"此处用描述类的顶级父类承接?????为什么CL_ABAP_OBJECTDESCR 不能承接????
OREF_TYPEDESCR = CL_ABAP_TYPEDESCR=>DESCRIBE_BY_OBJECT_REF( OREF ).

"此处向下转型
OREF_CLASSDESCR ?= OREF_TYPEDESCR.

GT_ATTRDESCR_TAB[] = OREF_CLASSDESCR->ATTRIBUTES.
GT_METHDESCR_TAB[] = OREF_CLASSDESCR->METHODS.

"动态访问类中的属性
LOOP AT GT_ATTRDESCR_TAB.
  ASSIGN OREF->(GT_ATTRDESCR_TAB-NAME) TO <FS_ATTR>.
  WRITE: / <FS_ATTR>.
ENDLOOP.

"动态访问类中的方法
LOOP AT GT_METHDESCR_TAB.
  CALL METHOD OREF->(GT_METHDESCR_TAB-NAME).
ENDLOOP.
```

## RTTC 使用 ##

### 动态创建数据 DATA 或对象 Object ###

```abap
  DATA: DREF TYPE REF TO DATA,
        OREF TYPE REF TO OBJECT.

  FIELD-SYMBOLS: <FS_DREF> TYPE ANY .

  "根据基本类型名动态创建数据
  CREATE DATA DREF TYPE ('I').
  ASSIGN DREF->* TO <FS_DREF>.
  <FS_DREF> = 1.

 "根据类名创建实例对象
  CREATE OBJECT OREF TYPE ('C1').

  WRITE: <FS_DREF>.
```

### 动态创建结构, 内表 ###

```abap
  DATA: DREF_I   TYPE REF TO DATA,
        DREF_C   TYPE REF TO DATA,
        DREF_STR TYPE REF TO DATA,
        DREF_TAB TYPE REF TO DATA.

  DATA: ELEM_TYPE   TYPE REF TO CL_ABAP_ELEMDESCR,
        STRUCT_TYPE TYPE REF TO CL_ABAP_STRUCTDESCR,
        TABLE_TYPE  TYPE REF TO CL_ABAP_TABLEDESCR,
        COMP_TAB    TYPE ABAP_COMPONENT_TAB WITH HEADER LINE.

  FIELD-SYMBOLS :<FS_ITAB> TYPE ANY TABLE.
  FIELD-SYMBOLS :<FS_LINE> TYPE ANY.

  "=====动态的创建基本类型数据====="
  ELEM_TYPE ?= CL_ABAP_ELEMDESCR=>GET_I(  ).

  "动态的创建基本类型数据对象"
  CREATE DATA DREF_I TYPE HANDLE ELEM_TYPE.

  "=====动态创建结构类型====="
  STRUCT_TYPE ?= CL_ABAP_TYPEDESCR=>DESCRIBE_BY_NAME( 'SFLIGHT' ).
  COMP_TAB[] = STRUCT_TYPE->GET_COMPONENTS( ). "组成结构体的各个字段组件"

  "向结构中动态的新增一个成员"
  COMP_TAB-NAME = 'L_COUNT'. "为结构新增一个成员"
  COMP_TAB-TYPE = ELEM_TYPE. "新增成员的类型对象"
  INSERT COMP_TAB INTO COMP_TAB INDEX 1.


  "使用结构类型对象来创建结构对象"
  STRUCT_TYPE = CL_ABAP_STRUCTDESCR=>CREATE( COMP_TAB[] ).
  CREATE DATA DREF_STR TYPE HANDLE STRUCT_TYPE.

  "=====动态创建内表====="
  "基于结构类型对象创建内表类型对象"
  TABLE_TYPE = CL_ABAP_TABLEDESCR=>CREATE( STRUCT_TYPE ).

  "使用内表类型对象来创建内表类型对象"
  CREATE DATA DREF_TAB TYPE HANDLE TABLE_TYPE.
  ASSIGN DREF_TAB->* TO <FS_ITAB>."将字段符号指向新创建出来的内表对象"


  "=====给现有的内表动态的加一列====="
  TABLE_TYPE  ?= CL_ABAP_TABLEDESCR=>DESCRIBE_BY_DATA( <FS_ITAB> ).
  STRUCT_TYPE ?= TABLE_TYPE->GET_TABLE_LINE_TYPE( ).
  COMP_TAB[] = STRUCT_TYPE->GET_COMPONENTS( ).
  COMP_TAB-NAME = 'FIDESC'.
  COMP_TAB-TYPE = CL_ABAP_ELEMDESCR=>GET_C( 120 ).
  INSERT COMP_TAB INTO COMP_TAB INDEX 2.

  STRUCT_TYPE = CL_ABAP_STRUCTDESCR=>CREATE( COMP_TAB[] ).
  TABLE_TYPE = CL_ABAP_TABLEDESCR=>CREATE( STRUCT_TYPE ).
  CREATE DATA DREF_TAB TYPE HANDLE TABLE_TYPE.
```

